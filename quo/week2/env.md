## 환경 구축하기

- 정적 코드 분석

  - 코드 실행과 별개로 코드 그 자체만으로 문제의 소지가 있는 코드를 찾아내, 사전에 수정한다.
  - ESLint
    - 작동 원리
      1. 코드를 **문자열**로 읽는다.
      2. 코드를 분석할 수 있는 parser로 코드를 **구조화**한다.
         (parser에 따라 json으로도 구조화한다. 타입, 이름, 정확한 코드 위치 등 세부 정보가 담겨있다.)
      3. 구조화된 트리(Abstract Syntax Tree)를 기준으로 각종 규칙과 대조한다.
      4. 규칙을 위반한 코드를 알리거나 수정한다.
    - 특정한 규칙의 모음을 plugins라고 한다.
    - eslint-plugin - 특정 프레임워크, 언어 등 관련 규칙을 모아놓은 패키지
    - eslint-config - eslint-plugin을 모은 패키지. 그룹 내 규칙을 동일하게 적용하고 싶은 경우 사용.
  - 주의할 점
    - Prettier와의 충돌 - 각각 다른 규칙이 적용되어 충돌이 발생할 수도 있다. 관여하는 영역을 나누는 것도 방법이다.
    - 예외 처리 - 대부분 규칙을 따르는게 맞다.
      - 괜찮다고 임의로 판단 - 지양한다.
      - 의존성 배열이 긴 경우 - 실행할 함수가 너무 길지 않은지 확인한다.
      - 한 번만 실행하고 싶은 경우 - 코드의 위치가 적절한가 고민한다.
    - ESLint 버전 충돌 - 설치된 라이브러리의 eslint와 내가 설치한 eslint의 버전이 안 맞을 수 있다. 의존성 문제를 해결하기 위해 peerDependencies 설정을 해보자.

- react-test-library

  - JS DOM을 테스트하는데 뿌리를 두고 있다. 모든 테스트를 DOM 위주로 진행한다. 컴포넌트 인스턴스가 아닌 DOM 노드를 테스트한다.
  - 프론트엔드의 테스트는 사용자에게 완전히 노출된 영역이므로, 어떻게 동작할지에 대해 최대한 예측해봐야 한다.
  - 대부분의 테스팅 프레임워크와 함께 사용할 경우, 테스트마다 `cleanup()`이 자동으로 실행된다. 만약 `cleanup()`이 실패하면 메모리 누수와 디버깅이 어려운 오류가 발생할 수 있다.
  - `ByTestId`는 다른 방법으로 Element를 선택할 수 없을 경우에만 사용한다. DOM의 `querySelector` 사용은 금지하고 차라리 `ByTestId`를 사용한다.
  - `userEvent` - `fireEvent`의 여러 이벤트를 순차적으로 실행해 사용자의 동작을 흉내 낸다.
  - `fireEvent` - 대부분의 이벤트를 발생시킬 때 사용하고, 훨씬 더 빠르다.
  - `jest.spyOn`
    - 특정 메서드의 실행 관련 정보를 얻을 때 사용한다.
    - 메서드의 원래 동작을 변경하지 않는다.
  - `mockImplementation`
    - 해당 메서드를 모의로 구현한다.(실행 컨텍스트를 변경한다.)
  - 비동기 컴포넌트 테스트
    - `msw`: fetch mocking을 돕는 라이브러리.
      - 브라우저에서는 서비스 워커로 실제 네트워크 요청을 가로채는 방식으로 작동한다.
      - 서버를 만들어, 요청에 대해 mocking 데이터로 대신 응답한다.
    - 다음 유틸들로 비동기 요청이 이후 작업이 제대로 수행되었는지 확인할 수 있다.
      - `findBy*` - 요소를 찾을 때까지 일정 시간 동안 기다린다.
      - `wait` - 에러가 발생하지 않을 때까지 대기 값만큼 기다린다.
      - `waitForElement` - Element가 변경 사항이 있을 때까지 기다린다.
      - `waitForDomChange` - Element가 변경 사항이 발생할 때까지 기다린다.
      - `waitForElementToBeRemoved` - Element가 화면에서 사라질 때까지 기다린다.
  - 사용자 정의 훅
    - `@testing-library/react`로 커스텀 훅을 테스트할 수 있다.
    - `renderHook`으로 커스텀 훅을 래핑하면, `renderHook` 내부에서 컴포넌트를 만들어 전달 받은 훅을 실행한다. 굳이, 테스트를 위한 컴포넌트를 만들 필요가 없다.
    - `rerender`, `unmount` 등의 유용한 함수도 제공한다.

- 테스트 작성시 고려할 점
  - 테스트 코드는 가능한 사람이 읽기 쉽게, 목적이 분명하게 작성되도록 한다.
  - 가장 취약하거나 중요한 부분의 테스트 코드를 가장 우선한다.
  - 사용자의 행동과 최대한 유사하게 테스트 코드를 작성한다.
  - 최종 목표는 애플리케이션이 비즈니스 요구사항을 충족하는지 확인하는 것이다.
