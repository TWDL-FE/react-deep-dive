# 리액트 훅

## useState

- 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.
- 내부는 state를 유지하기위해 클로저와 useReducer를 이용해 구현돼 있다.
- 게으른 초기화란 기본 값을 에 함수를 넘기는 것으로, 값에 복잡하거나 무거운 연산을 포함할 때 사용한다.
- 렌더링마다 함수 컴포넌트의 함수가 다시 실행되지만, useState의 인수(내부)로 들어가는 작업은 최초 렌더링 이후에는 실행되지 않는다.

## useEffect

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다. 어떤 상태 값과 함께 실행되는지가 중요하다.
- 함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다. useEffect는 렌더링마다 의존성에 잇는 값을 이전 값과 비교해서 부수 효과를 실행하는 평범한 함수다.
- useEffect 내부의 코드는 클라이언트 사이드에서 실행되는 것을 보장하므로, SSR의 경우에 브라우저 API 등에 의존하는 코드를 사용해도 된다.
- useEffect 내부 코드는 컴포넌트 렌더링 완료 이후에 실행되지만, 일반 함수는 렌더링 도중에 실행된다. SSR에서는 서버에서도 실행된다.
- 의존성 배열은 Object.is를 기반으로 얕은 비교를 수행한다.
- 주의할 점
  - eslint-disable-line react-hooks/exhaustive-deps 주석은 자제하기. ⇒ 호출 위치가 최선인지 점검하자.
  - useEffect의 첫 번째 인수에 함수명을 부여하기. useEffect의 목적을 명확히 하고, 그 책임을 최소한으로 좁힐 수 있다.
  - 거대한 useEffect 지양하기. ⇒ 여러 개의 useEffect로 쪼개거나 useCallback과 useMemo 활용하면, useEffect를 파악하기 수월하다.
  - 불필요한 외부 함수 만들지 말기. ⇒ 내부에 정의하기.

## useMemo

- 비용이 큰 연산에 대한 결과를 저장해 두고, 이 값을 반환하는 훅이다.
- 컴포넌트도 가능하다.

## useCallback

- 인수로 넘겨 받은 콜백 자체를 기억한다.
- 콜백이 리렌더링되면 주소가 바뀌므로 새로운 콜백이 되기 때문에 useCallback으로 재생성하지 않을 수 있다.
- useMemo의 반환 값을 함수로 만들어서서, useCallback을 구현할 수 있다.

## useRef

- 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태 값을 저장한다. 하지만 값이 변하더라도 렌더링을 발생시키지 않는다.
- 컴포넌트가 렌더링될 때만 생성되며, 컴포넌트 인스턴스가 여러 개라도 각각 별개의 값을 바라본다. 다시말해, 렌더링을 발생시키지 않고 원하는 상태 값을 저장할 수 있다.

## useContext

- context는 props drilling으로 인한 문제를 극복하기 위한 개념으로, 명시적 props 전달 없이 props를 하위 컴포넌트로 내려준다.
- 컴포넌트가 복잡해질수록 컨텍스트 사용도 사용하기 쉽지 않은데, useContext를 사용하는 환경이 컨텍스트가 존재하는 환경인지 확인해야 한다. 즉, 컨텍스트가 한 번이라도 초기화되었는지 확인한다.
- 컨텍스트를 사용하는 컴포넌트는 재활용이 어려움을 인지해야한다. 의존성을 해결하는게 아니다.
- 컨텍스트 사용 범위를 최소한으로 줄여주는게 중요하다. 하위 컴포넌트가 모두 리렌더링 대상이 되므로 불필요한 리소스 낭비를 막자. 컴포넌트에 memo를 쓰는 것도 방법이다.

## useReducer

- state를 사전에 정의된 dispatcher로만 수정할 수 있게 만든다.
- dispatcher는 컴포넌트 외부에서, state 수정과 사용은 컴포넌트에서 이뤄지도록 한다. 사용 로직과 관리 로직의 분리가 가능하다.
- 복잡한 state나 state 덩어리를 관리할 때 유용하다.
- 내부적으로 클로저를 사용해 state를 관리한다. useState와 유사하다.

## useImperativeHandle

- forwardRef
  - 상위 컴포넌트에서 하위 컴포넌트로 ref를 전달하는 방법.
- useImperativeHandle
  - 상위 컴포넌트로부터 넘겨받은 ref를 수정할 수 있는 훅이다.

## useLayoutEffect

- useEffect와 함수 시그니처는 동일하나, 모든 DOM의 변경 후에 동기적으로 발생한다.
- 동기적으로 작동하므로 컴포넌트가 잠시 중지될 수 있다.
- useEffect 실행 전에 실행할 필요가 있는 작업에 사용되지 않을까?
- 순서
  1. DOM 업데이트
  2. useLayoutEffect
  3. 브라우저에 변경 사항 반영
  4. useEffect

## useDebugValue

- 개발 과정에서 사용되며, 디버깅하고 싶은 정보를 이 훅에다 사용하면 리액트 개발자 도구에서 볼 수 있다.
- 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있다.
- 오직 훅 내부에서만 실행가능하고, 컴포넌트에서는 동작하지 않는다.

## 훅의 규칙

- 최상위에서만 훅을 호출한다. 동일한 순서로 훅이 호출되는 걸 보장해야 한다.
- 함수 컴포넌트, 사용자 정의 훅에서만 훅을 호출할 수 있다.
- 훅에 대한 정보는 linked list로 구현되 있다. 호출 순서에 의존해 저장된다. 이전 값에 대한 비교와 실행도 이를 기반으로 이루어진다.

## 사용자 정의 훅

- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 사용되며, 개발자가 필요한 훅을 만드는 기법이다.
- use로 시작한다는 규칙이 있다.
- 그 자체로는 렌더링에 영향을 미치지 못하여, 고차 컴포넌트에 비해 컴포넌트 내부에 미치는 영향을 최소화 할 수 있다.

## 고차 컴포넌트

- 컴포넌트 자체의 로직을 재사용하기 위한 방법.
- 관행적으로 with를 이름 앞에 붙인다.
- 로그인 확인, 에러 페이지를 보여주는 컴포넌트에 사용할 수 있다. (렌더링 결과물에 영향을 미치는 공통 로직에 사용)
- 부수 효과를 최소화한다. 컴포넌트를 인수로 받게 되는데, 반드시 props를 변경하거나 추가/삭제 하는일은 없도록 하자.
- 고차 컴포넌트는 wrapper 지옥이 발생할 수 있으므로 최소한으로 사용한다. 복잡성이 너무 커질 수 있다.
- React.memo
  - 컴포넌트의 props가 변경되지 않았음에도, 부모 컴포넌트가 리렌더링되어 같이 리렌더링되는 경우 사용한다.
- 고차 함수
  - 함수를 인수로 받거나 결과로 반환하는 함수.
  - Array의 map, forEach, reduce 등이 해당된다.
  - 함수를 반환하는 클로저 또한 포함된다.
