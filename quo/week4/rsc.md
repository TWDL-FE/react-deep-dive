# React Server Components

- 그런데 처음 요청부터 데이터를 준비하면 되지 않나? 서버가 할 수 있는 일은 모두 처리하고 보내주자.
- 이걸 next.js가 SSR로 해결했다. page router는 서버가 요청을 받으면 getServerSideProps함수를 호출하고, 서버에서 렌더링된 후, 클라이언트에서 hydrate된다. 다만, 트리의 꼭대기인 페이지만 적용이되는 단점이 있다.
- 앞에서 발생한 단점을 React Server Component가 해결한다. 서버 전용 컴포넌트다. UI를 생성하기 위해 서버에서 한 번만 실행된다. 클라이언트로 전송되고 불변이다. 이는 리액트의 API들과 호환되지 않음을 의미한다. 긍정적인 측면은 리액트 렌더링에서 사이드 이펙트 없이 한번만 실행되는 컴포넌트도 구현이 가능하다는 점이다.
- 서버 컴포넌트는 JS 번들에 포함되지 않으므로 hydrate나 리렌더링 되지 않는다.(html로 변한다는 말인듯)
- 새로운 패러다임의 시작이라 보면 된다. 상태가 변하는 클라이언트 컴포넌트에서 상태가 변하지 않는 서버 컴포넌트로 기본 컴포넌트가 변경됐다는 말이다. 그래서 nextjs의 app router에서는 클라이언트 컴포넌트를 쓰기 위해서 ‘use client’를 표시해줘야 한다.
- 만약 트리 중간에 클라이언트 컴포넌트가 있다고 가정한다면, 그 하위 컴포넌트들은 ‘use client’를 선언하지 않아도 암시적으로 클라이언트 컴포넌트로 변환된다. 상위 컴포넌트가 리렌더링되면 하위 컴포넌트들도 리렌더링 되어야 하기 때문이다.
- 여기에는 파훼법이 있는데 상위의 클라이언트 컴포넌트의 리렌더링 관련 코드를 모듈로 가져오기를 하면, 해당 컴포넌트는 ‘use client’를 작성할 필요가 없다. 파일/모듈 수준에서 지시문이 작성하기 때문이다. 하위 컴포넌트들이 서버 컴포넌트일 수 있는 이유는 children prop을 통해 상위 컴포넌트로 전달되어, 상위 컴포넌트는 얼마든지 리렌더링을 할 수 있어서이다. 더이상 번들 사이즈로 인해 기능이냐 성능이냐를 따질 필요가 없다.
- 반대로 서버 컴포넌트를 클라이언트 컴포넌트에서 가져오지 못하는데, 이 파훼법은 클라이언트 컴포넌트가 래퍼 컴포넌트가 되면 된다.

### Client Component

- 상태관리와 훅, 이벤트 핸들러 사용이 가능하고, 브라우저 API에도 접근이 가능하다.
- ‘use client’로 설정할 수 있다. 그 하위 컴포넌트들도 모두 적용된다.
- 렌더링 과정 (첫 방문이나 새로 고침으로 인한 ‘전체 페이지 로딩’인지, ‘페이지 내 이동’인지에 따라 렌더링 과정이 다르다.)

  - 전체 페이지 로드일 경우: 서버 컴포넌트 렌더링과 동일하다.
  - 페이지 내 이동일 경우: 전적으로 클라이언트에서 렌더링된다.
    1. 클라이언트 컴포넌트 JS 번들이 다운로드되고 파싱된다.
    2. 리액트는 RSC Payload로 클라이언트와 서버 컴포넌트 트리를 조정하고, DOM을 업데이트 한다.

- 앱이 브라우저에서 로드될 때, 컴포넌트 코드를 다운로드하고, HTML을 구문 분석하고 이벤트 리스너를 DOM에 연결하며, 그리고 스토어에서 데이터를 가져온다. 이렇게 hydrate를 통해 앱을 작동시킨다.
- 문제점
  - layout shift - 레이아웃 재조정으로 렌더링되는 시간이 늦어진다.
  - waterfall - 현재 작업을 시작하기 위해 이전 응답을 기다리는 현상. 네트워크, 컴포넌트 단에서 모두 발생할 수 있음.
  - performance - 컴포넌트는 js 함수다. 요청을 보낼 때 받아야할 컴포넌트 관련 js 에셋이 많아진다.

\*\* hydrate  
 - 말라비틀어져 아무것도 할 수 없는 html에 상호작용이라는 물을 주는것과 같다.  
 - 정적 HTML을 상호작용 가능하게 만들기 위해, DOM에 이벤트 리스너를 붙이는 과정.

### Server Component

- 요청이 오면 그 순간 서버에서 딱 한 번 실행되므로, 상태를 가질 수 없다. 렌더링 생명주기도 사용할 수 없다.
- effect, state에 의존하지 않고 서버에서 제공하는 기능만 사용하는 훅은 사용 가능하다.
- 브라우저 API, 서버 데이터에 접근할 수 없다.
- 제로 번들 사이즈를 지향.
- 서버 컴포넌트가 렌더되면 RSC payload라는 데이터 포맷으로 클라이언트에 전송된다. 여기에는 서버 컴포넌트 렌더 결과, 클라이언트 컴포넌트가 어디에 위치해야하는지와 JS 파일 참조에 대한 내용이 들어있다. 클라이언트에서 리액트는 이 정보들을 통합해서 DOM을 업데이트한다.

- next.js는 기본이 서버 컴포넌트다. 클라이언트 컴포넌트를 트리 말단에 선언하자.
- 서버 컴포넌트는 백엔드이므로 백엔드 api를 컴포넌트에서 호출해도 문제가 없다.
- 렌더링 과정
  - 서버
    1. React가 서버 컴포넌트를 RSC Payload(클라이언트 컴포넌트 참조)로 렌더링한다.
    2. Next.js가 RSC Payload와 클라이언트 컴포넌트 js instructions로, 서버에서 HTML을 렌더링한다.
  - 클라이언트 1. 초기 페이지 로딩에 HTML이 사용된다. 2. RSC Payload는 클라이언트와 서버 컴포넌트의 트리를 조정하고, DOM을 업데이트한다. 3. js instructions는 클라이언트 컴포넌트를 hydrate하고 앱을 상호작용 가능하게 만든다.  
    \*\* RSC Payload: 리액트 서버 컴포넌트 트리의 압축된 바이너리.

react 버전 릴리즈 노트

- 클라이언트, SSR 서버와 분리된 환경에서, 번들링전 미리 렌더링 되는 새로운 컴포넌트다.
- 분리된 환경은 서버다. 빌드시 한 번 실행되거나 웹서버 요청에 대해 실행된다.

### Server Action

- “use server” 지시자를 선언하고, 비동기 함수여야 한다.
- form action: post 요청이 아닌 요청받은 경로와 ACTION_ID를 통해 미리 빌드된 서버 액션을 호출한다.
- useTransition: 이전 처럼 REST API 통신이 아닌, 지연을 통해 데이터를 받아오고 렌더링한다.
- 클라이언트 컴포넌트에서는 “use server”가 선언된 모듈을 가져와서 사용할 수 있다.
