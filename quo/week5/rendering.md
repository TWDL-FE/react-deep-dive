## JSX

- 페북에서 독자적으로 개발했으며, ECMAScript 표준이 아니다. 바로 실행하면 에러가 발생한다.
- JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해두고, 이 JSX를 트랜스파일이라는 과정을 거쳐 ECMAScript가 이해할 수 있는 코드로 변경하는 것이 목표이다.
  ### 정의
  - 컴포넌트는 반드시 대문자로 시작해야하며, HTML 태그와 구분 짓기 위해서다.
  ```jsx
  function Component(){
  	return (
  		<> {// JSXFragment}
  			<JSXElement> {// JSXOpeningElement}
  				string
  			</JSXElement> {// JSXClosingElement}
  			<JSXSelfClosingElement /> {// JSXSelfClosingElement}
  		</>
  	)
  }
  ```
  - 다음과 같은 형태도 가능하다.
  ```jsx
  function Component() {
  	return (
  		<A.B>
  			<A:B.C></A:B.C>
  			<$></$>
  			<_></_>
  		</A.B>
  	)
  }
  ```

### JSX → JS 변환

- @babel/plugin-transform-react-jsx 플러그인을 통해 트랜스파일된다.
- JSX 반환 값은 결국 React.createElement로 귀결된다.

## 가상 DOM과 리액트 파이버

- 리액트는 실제 DOM이 아닌 가상 DOM을 운영한다.
  ### DOM과 브라우저 렌더링 과정
  1. 브라우저가 HTML 파일을 다운로드한다.
  2. 렌더링 엔진은 HTML을 파싱해서 DOM 트리를 만든다.
  3. 2번 과정에서 CSS 파일을 만나면 해당 파일도 다운로드한다.
  4. 3번의 CSS를 파싱해 CSSOM 트리를 만든다.
  5. 2번에서 만든 DOM노드를 순회하며, 사용자 눈에 보이는 노드만 방문한다.
  6. 5번 과정에서 해당 노드에 대해 CSSOM 정보를 찾고 적용한다.

### 가상 DOM 탄생 배경

- 노출 여부나 사이즈 변경이 일어나면 레이아웃과 리페인팅이 발생하여 브라우저에 부담이 된다. 하위 요소가 많은 DOM의 변경이 일어나는 경우도 마찬가지다. SPA의 경우에도 대부분의 요소를 삭제하고 삽입하고 위치를 계산하는 과정을 수없이 거쳐서 부담이 크다.
- 가상 DOM은 웹페이지가 표시할 DOM을 메모리에 저장하고 리액트가 준비가 완료되었을 때, 실제 DOM에 반영한다. 이 방식이 충분히 빠르다는 것이지 일반적으로 DOM을 관리하는 것보다 항상 빠르다는 말은 아니다.

### 가상 DOM을 위한 아키텍처, 리액트 파이버

**파이버(fiber)**

- 파이버는 DOM 변경의 정보를 가지고 있고, 파이버 reconciler는 파이버를 기준으로 화면에 렌더링을 요청한다. 재조정은 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)이다.
- 파이버의 목표는 리액트 앱에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다.
- 파이버가 하는 일 - 비동기
  - 작업을 작은 단위로 분할하고 우선순위 매기기
  - 작업 일시 중지하고 나중에 다시 시작하기
  - 이전에 했던 작업을 재사용하거나 폐기하기
- 파이버는 단순한 js 객체로 구성돼 있고, 최초 마운트 이후 가급적이면 재사용된다.
- 파이버는 하나의 `element`에 하나가 생성되는 1:1 관계를 가진다.
- `state`가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점에 실행된다.

**파이버 트리**

- 파이버 트리는 현재 모습을 담은 current 트리와 작업 중인 상태를 나타내는 `workInProgress` 트리로 두 개가 존재한다.
- 더블 버퍼링(커밋 단계) - 파이버 작업이 끝나면 단순히 포인터만 변경해서 `workInProgress` 트리를 현재 트리로 바꾼다. 즉, 보이지 않는 곳에서 미리 완성시킨다음, 새로 바꾼다.
  1. current를 기준으로 작업이 시작된다.
  2. 업데이트 발생 시, 새로운 데이터로 `workInProgress` 트리를 빌드한다.
  3. 작업이 끝나면 렌더링에 이 트리를 사용한다.
  4. 렌더링에 반영이 완료되면 `workInProgress`가 새로운 current가 된다.

**파이버의 작업 순서**

- 과거에는 동기식으로 처리했지만 현재는 우선순위가 높은 다른 업데이트가 오면 현재 작업을 일시 정지나 새롭게 만들거나 폐기를 한다.

1. 리액트는 `beginWork` 함수를 실행해 파이버 작업을 수행하고, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번 작업이 끝나면 `completeWork` 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2, 3번이 끝나면 `return`으로 돌아가 작업이 완료되었음을 알린다.

### 파이버와 가상 DOM

- 파이버는 비동기 작업이지만 실제 DOM에 반영하는 것은 동기적으로 진행된다. 그래서 처리량이 많으면 불완전한 표시를 대비해 메모리상에서 먼저 수행해 최종 결과물만 DOM에 적용하는 것이다.
- 파이버와 가상 DOM은 동일한 개념이 아니다. 파이버는 재조정자 역할을 하므로 RN에서도 사용된다.

## 클래스/함수 컴포넌트

### 클래스 컴포넌트

- `render`
  - UI를 렌더링할 때 사용 된다.
  - 순수 함수여야 한다.
- `componentDidMount`
  - 컴포넌트 마운트 후 즉시 실행된다.
  - 가능하면 state 변경은 생성자에서 하자.
- `componentDidUpdate`
  - 컴포넌트 업데이트 직후 실행된다.
  - 조건문이 없으면 정의한 state 변경이 계속 일어날 수 있다.
- `componentWillUnmount`
  - 컴포넌트 언마운트나 사용되지 않기 직전에 실행된다.
  - 보통 클린업 함수를 호출하며, state 변경은 호출할 수 없다.
- `shouldComponentUpdate`
  - 리렌더링 없이 state나 props를 변경하고 싶을 때 사용한다.
- `static getDerivedStateFromProps`
  - `render` 호출 직전에 호출된다.
  - 반환 객체는 `state`에 반영된다. null은 아무일도 일어나지 않는다.
- `getSnapShotBeforeUpdate`
  - DOM 업데이트 직전에 호출된다.
  - 반환 값은 `componentDidUpdate`로 전달된다.
  - 렌더링 전, 윈도우 크기 조절이나 스크롤 위치 조정에 유용하다.
- `getDerivedStateFromError`
  - 자식 컴포넌트에서 에러가 발생했을 때 호출된다.
  - 반환 값은 `state` 값이어야 하며, 렌더링 과정에서 호출되므로 `state` 반환 외에 모든 작업이 안된다.
- `componentDidCatch`
  - 자식 컴포넌트에서 에러가 발생했을 때 호출되며, `getDerivedStateFromError` 이후에 실행된다.
  - 앞서 하지 못했던 부작용을 일으킬 수 있다. 커밋 단계에서 실행되기 때문이다.
- 한계
  - 데이터 흐름 추적이 어렵다.
  - 내부 로직 재사용이 어렵다.
  - 클래스는 함수에 비해 상대적으로 어렵다.
  - 코드 크기 최적화가 어렵다.
  - 핫 리로딩이 불리하다.

### 함수 컴포넌트

- 생명주기 메서드의 부재
  - `useEffect` 훅을 사용해 생명주기 메서드와 비슷하게 구현할 수 있다. 동기적으로 부수 효과를 만들 수 있다.
- 함수 컴포넌트와 렌더링된 값
  - 함수 컴포넌트는 렌더링된 값을 고정하기 때문에 이벤트 발생 시점의 값을 쓰고, 클래스 컴포넌트는 실제 실행 시점의 값을 쓴다.
  - 클래스 컴포넌트는 `props`의 값을 항상 `this`로부터 가져오기 때문이다.
  - 함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 `props`와 `state`를 기준으로 렌더링된다.

## 렌더링

- 브라우저 렌더링 - HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정.
- 리액트 렌더링 - 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정.
- 리액트의 개발자는 리액트 렌더링 과정을 최소한으로 줄여야 한다.
  ### 리액트 렌더링
  - 트리 안에 모든 컴포넌트들이 `props`와 `state`의 값을 기반으로 어떻게 UI를 구성하고 DOM을 브라우저에 제공하는지 계산하는 일련의 과정이다.
  - 발생 시점
    - 최초 렌더링
    - 리렌더링 - 최초 렌더링 이후 모든 렌더링.
      - 클래스 컴포넌트의 `setState`
      - 클래스 컴포넌트의 `forceUpdate` - 강제로 렌더링하며, render 메서드에서는 사용 금지이다.
      - 함수 컴포넌트의 `useState`의 setter
      - 함수 컴포넌트의 `useReducer`의 `dispatch`
      - 컴포넌트의 `key` `props` 변경
        - `key`는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다.
        - 파이버 트리들을 비교할 때, 같은 컴포넌트인지 구별하는 값이 `key`다.
      - `props` 변경
      - 부모 컴포넌트 렌더링 - 자식은 따라서 무조건 리렌더링된다.
  - 프로세스
    - 루트 컴포넌트부터 아래로 내려가면서 업데이트가 필요한 모든 컴포넌트를 찾는다.
    - 클래스 컴포넌트라면 `render` 메서드를, 함수 컴포넌트라면 컴포넌트 자체를 호출한 뒤, 결과물을 저장한다.
    - 호출 과정에서 JSX ⇒ `React.createElement` 함수 ⇒ 객체로 변환된다.
    - 각 컴포넌트의 렌더링 결과물을 수집하고, 실제 DOM과 비교해서 모든 변경 사항을 차례로 수집한다. 이게 리액트의 재조정(Reconciliation)이다.
    - 재조정이 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다.
  - 렌더와 커밋
    - 렌더 단계
      - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업으로, 컴포넌트를 실행(render or return)한 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계이다.
      - `type`, `props`, `key` 중 하나라도 변경되면 변경이 필요한 컴포넌트가 된다.
    - 커밋 단계
      - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정이며, 이 단계가 끝나면 브라우저 렌더링이 발생한다.
    - 리액트의 렌더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것은 아니다. 변경 사항을 계산했지만, 변경 사항이 없다면 커밋 단계는 생략된다.
