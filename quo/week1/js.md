# 자바스크립트

## 동등 비교

- 숫자형
  - 내부적으로 64비트 형식으로 표현되므로 64비트가 필요. 52는 숫자, 11은 소수점 위치, 1은 부호를 저장. 64가 넘치면 Infinity 처리
  - Special numeric value 포함. `NaN`, infinity, -infinity
    - `NaN`은 자기 자신을 포함하여 어떤 값과도 같지 않기 때문에 `===`이 아닌 `isNaN`으로 테스트해야한다.
    - `isFinite(value)`는 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환함. 문자열이 일반 숫자인지 검증할 수 있음.
  - 숫자 연산은 안전하기 때문에, 계산중 오류가 발생해도 연산을 종료하지(죽지) 않는다.
- BigInt
  - 9천조 이상의 숫자를 표현. (2에 53승 - 1)
  - 정수 뒤에 n을 붙여 표현 가능
- 문자열
  - escape character(`\`)를 이용해 특수기호를 넣을 수 있다. `\’` . 역슬래시는 문자열을 읽기 위한 용도이며, 역할이 끝나면 사라져 메모리에 저장되는 문자열엔 없다.
  - 문자열은 불변이다.
  - js 내장 함수 뿐만 아니라, 비트 NOT 연산자를 이용해서 문자열을 찾을 수 있다. `if (~str.indexOf(...))` 패턴의 코드를 만나면 '부분 문자열인지 확인’하는 코드다.(32비트를 넘어가지않는 아주 길지 않은 문자열에만 작동)
  - 문자열 비교
    - 소문자는 대문자보다 크다.
    - `str.codePointAt(pos)`를 이용해 문자의 코드를 알아낼 수 있다. 반대도 `String.fromCodePoint(code)` 사용가능.
    - 대부분의 모던 브라우저는 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)를 따르며, [str.localeCompare(str2)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)로 쉽게 알 수 있다.
    - 유니코드 정규화는 보기에는 같은 글자인데 유니코드 조합이 다른 경우, 비교할 수 있게 한다. [str.normalize()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
- null - js에선 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타냄
- undefined
  - 값이 할당되지 않은 상태
  - 변수가 ‘비어있거나’ ‘알 수 없는’ 상태라는 걸 나타내려면 null을 사용. undefined는 값이 할당되지 않은 변수의 초기값을 위해 예약어로 남겨두기.
- 비교 연산자
  - 불린형 반환
    - true: 긍정, 참, 사실
    - false: 부정, 거짓, 사실이 아님
  - 문자열 비교: ‘유니코드’순으로 문자열을 비교. 뒤쪽 문자열이 앞쪽보다 크다고 판단되며, 알파벳의 대소문자를 따짐(소문자가 더 큼).
  - 다른 형을 가진 값 간의 비교: 자료형이 다르면, js는 이 값들을 숫자형으로 바꿈
  - 일치 연산자
    - 동등 연산자(equality operator) `==`는 `0 == false`를 구별 못해, `true` 반환. 숫자로 형 변환후 비교하기 때문.
    - 일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값 비교. `0 === false` 연산으로 `false` 반환.
    - Object.is는 ES6 문법으로, 일치 연산자와 유사하며 그 한계를 극복하기 위해 만들어짐. 객체 비교는 똑같음.
      ```tsx
      Object.is(-0, +0); // false
      Object.is(Number.NaN, NaN); // true
      Object.is(NaN, 0 / 0); // true
      ```
  - null이나 undefined 비교
    - `null === undefined` 자료형이 다르므로 `false`
    - `null == undefined` 특별 규칙으로 `true`
    - 산술 연산자, 기타 비교 연산자 사용하여 비교시, null과 undefined는 숫자형으로 변환
  - null vs 0
    - `==`와 기타 비교 연산자 `<`, `>`, `≤`, `≥`의 동작 방식은 다름. 후자는 `null`이 숫자형으로 변환되고, 전자는 형 변환을 하지 않음.
    - `==`는 `undefined`나 `null`일 때, 형 변환을 하지 않음. 둘끼리 비교할 때만 `true`를 반환하고, 각자 다른 값과 비교할 때는 무조건 `false`를 반환.
  - 비교 연산시 `undefined`나 `null`이 인수로 오지 않도록 특별히 주의하기. 그 여부를 확인하는 코드를 따로 추가하는 습관 들이기.

## 함수

- 프로그램을 구성하는 주요 ‘구성 요소(building block)’이다. 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있다.
- 함수 외부 변수(outer variable)과 똑같이 지역 변수(local variable)을 함수 내부에 재정의 할 수 있다. 함수 내에서 호출시 지역 변수에 의해 외부 변수가 가려진다.
- 매개변수(parameter)는 함수 안에 전달되는데, 이때 지역변수에 복사된 값을 사용하므로 수정해도 외부 변수에 반영되지 않는다. 객체 내부 값들은 원본을 가르키고 있으므로 반영된다.
  - 매개변수는 함수 선언 방식 괄호 사이에 있는 변수(선언 시 쓰이는 용어).
  - 인수는 함수를 호출할 때 매개변수에 전달되는 값(호출 시 쓰이는 용어).
  - 인수를 전달하지 않아도 에러가 발생하진 않고, `undefined`가 기본 값이 된다.
- `return`은 함수 내 어디서든 사용할 수 있고, 함수 실행은 즉시 중단되고 함수를 호출한 곳에 값을 반환한다. `return` 지시자가 없는 함수는 `undefined` 반환.
- 함수 이름만 보고도 어떤 기능을 하는지 알 수 있게 자기 설명적 코드(self-describing)로 작성하기. 즉, 이름에 언급된 동작만 정확히 수행해야 하므로, 함수는 동작 하나만 담당해야 한다. 함수는 동작을 수행하기 때문에 이름이 주로 동사다.
- 함수가 길어지면 잘게 쪼갤 때가 되었다는 신호로 인식하기.
- js에서 함수는 “특별한 종류의 값”이지 “특별한 동작을 하는 구조”가 아니다. 값이므로 `()` 없이 호출되면, 코드가 문자형으로 출력된다.
  - 함수 선언(Function Declaration) `function hello() {}`
    - 실행 흐름이 함수에 도달하기 전에도 호출할 수 있다. 따라서 전역 함수 선언문은 스크립트 어디에서나 사용 가능하다. js는 스크립트 실행 준비 단계에서 함수 선언문을 찾고, 생성한다.
    - 함수가 선언된 코드 블록 안에서만 유효하기 때문에, 블록 밖에서는 접근하지 못한다.
  - 함수 표현식(Function Expression) `let hello = function () {}`
    - 실행 흐름이 함수에 도달했을 때 함수를 생성. 따라서 이때부터 함수를 사용할 수 있다.
    - 코드 블록 외부의 변수에 할당하면, 블록 밖에서 접근 가능하다.
  - 함수 선언 전에 호출, 가독성 때문에 보통은 함수 선언을 더 선호. 이게 부적절할 때 함수 표현식 사용.
- 콜백 함수는 인수로 함수를 전달하고, 필요하다면 그 함수를 “나중에 호출(called back)”하는 것.
- 화살표 함수 `(…args) ⇒ expression`는 본문이 한 줄인 함수를 작성할 때 유용하다.
- 함수도 객체의 일종이다.
- 함수 규칙
  - side effect를 최소한으로 줄이는 순수 함수 지향하기.
  - 가능한 작게 만들고 한가지 일만 하기.
  - 이해하기 쉽고 간단한 이름 붙이기.

## 클래스

- constructor
  - 하나만 가능하고, 없어도 된다.
- instance method
  - 모든 객체는 프로토타입을 가지고 있다. 프로토타입 체이닝은 프로토타입에 있는 메서드를 찾아서 실행을 돕는다. 특정 속성을 찾을 때, 프로토타입을 타고 자기 자신부터 최상위 객체인 Object까지 훑게 된다.
- static method
  - 인스턴스가 아닌 클래스에서 호출한다.
  - this는 인스턴스가 아닌 클래스 자신을 가르키므로, 활용하기 어렵다.

## 클로저

- 코드 블록 `{…}`: 블록 안에서 선언한 변수는 안에서만 사용 가능.
- 중첩 함수(nested): 함수 내부에 선언한 함수
- 렉시컬 환경

  1. 변수
     - js에선 실행 중인 함수, 코드 블록, 스크립트 전체는 렉시컬 환경(Lexical Environment)이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.
     - 렉시컬 환경 객체는 두 부분으로 구성
       - 환경 레코드 - 모든 지역 변수를 프로퍼티로 저장하는 객체. `this`도 포함
       - 외부 렉시컬 환경에 대한 참조 - 외부 코드와 연관됨
     - 변수를 변경하면 환경 레코드의 프로퍼티가 변경된다.
     - 변수는 let을 만나기 전까지 사용할 수 없다.
  2. 함수 선언문
     - 함수 선언문(function declaration)으로 선언한 함수는 일반 변수와 달리 바로 초기화된다. 변수에 함수를 할당한 함수 표현식(function expression)은 변수처럼 초기화된다.
  3. 내부와 외부 렉시컬 환경
     - 코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 찾지 못하면 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 검색 범위를 확장한다. 이 과정은 전역 렉시컬 환경까지 반복된다.
     - 끝내 찾지 못하면 엄격 모드에선 에러가, 비엄격 모드에서는 새로운 전역 변수가 만들어진다.
  4. 함수를 반환하는 함수

     - 모든 함수는 생성된 곳의 렉시컬 환경을 기억한다. 함수는 `[[Environment]]`라는 숨김 프로퍼티(불변)가 있는데, 여기에 생성된 곳의 렉시컬 환경에 대한 참조가 저장된다. 호출 장소와 상관 없다.

     - 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄진다.

- 클로저
  - 외부 변수를 기억하고 이에 접근할 수 있는 함수.
  - 내부 변수를 외부에서 수정하는 것을 방지하고 정해진 루트로 호출하게 만든다.

## 이벤트 루프와 비동기 통신의 이해

브라우저, Node.js의 js 실행 흐름은 이벤트 루프에 기반한다.

### 싱글 스레드 JS

- 프로세스는 메모리상에서 실행되는 작업 단위다. 하나의 프로그램 실행은 하나의 프로세스를 가진다.
- 스레드는 그보다 더 작은 단위다. 하나의 프로세스에서 동시에 여러 개의 작업을 수행한다. 스레드 간 메모리 공유 가능.
- 비동기 함수는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 이는 브라우저나 Node.js의 역할이다.

### 이벤트 루프

- 태스크가 들어오길 기다렸다가, 오면 처리하고 없으면(호출 스택이 비었음) 잠드는(CPU 자원 소비 0), 끊임없이 돌아가는 자바스크립트 내 루프다. 먼저 들어온 순서대로 태스크를 처리한다.
- 호출 스택은 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다
- 외부 스크립트, 사용자 이벤트, `setTimeout` 등으로 활성화된다.
- 코드 실행은 싱글 스레드에서, 외부 Web API등은 JS 코드 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것이다.
- 매크로태스크 큐(macrotask queue): js 엔진이 기존 태스크를 처리하고 있을 때, 새로운 태스크가 대기하는 공간.
- 엔진이 특정 태스크를 처리하는 동안엔 렌더링이 절대 일어나지 않는다. 처리 시간이 길어지면 브라우저에서 ‘응답 없는 페이지’라는 창을 만나게 된다. 여러 이유로 무한 루프에 빠진 경우이다.
- 예시
  - 무거운 동기식 태스크를 처리 할 때, `setTimeout`으로 작업을 중간중간 쪼개주면, 또 다른 이벤트를 받는데 문제 없다. 그리고 성능 개선을 위해 작업 앞으로 스케줄링 코드를 옮길 수도 있다.
  - 작업을 쪼개서 의도적으로 진행 상태를 수치로 보여줄 수도 있다.
    ```tsx
    <div id="progress"></div>

    <script>
      let i = 0;

      function count() {

        // 무거운 작업을 쪼갠 후 이를 수행
        do {
          i++;
          progress.innerHTML = i;
        } while (i % 1e3 != 0);

        if (i < 1e7) {
          setTimeout(count);
        }

      }

      count();
    </script>
    ```
  - 특정 이벤트를 뒤로 연기시켜야 할 경우도 사용 가능하다.

### 매크로태스크와 마이크로태스크

- 매크로태스크
  - 실행해야 할 태스크의 집합으로 `set` 형태다. 실행 가능한 가장 오래된 ‘비동기 함수의 콜백 함수’나 ‘이벤트 핸들러’부터 처리한다.
  - 이벤트 루프는 한 개 이상의 태스크 큐를 가진다.
  - ex) `setTimeout`, `setInterval`, `setImmediate`
- 마이크로태스크는 코드로만 만들 수 있다.
  - 이벤트 루프는 하나의 마이크로 태스크 큐를 갖는데, 태스크 큐와 다른 태스크를 처리하며 우선권을 갖는다.
  - 대표적으로 `Promise`가 마이크로 태스크 큐이며, `setTimeout`보다 빨리 실행된다. 마이크로 태스크 큐가 빌 때까지 태스크 큐 실행은 뒤로 미루어진다.
  - ex) `Promise`와 그 핸들러 `.then/catch/finall` 그리고 `await` 모두 해당된다. `queueMicrotask(func)`로 함수를 처리할 수도 있다. `process.nextTick`, `MutationObserver`도 가능.
- **자바스크립트 엔진은 *매크로태스크 하나*를 처리할 때마다 또 다른 매크로태스크나 렌더링 작업을 하기 전에 마이크로태스크 큐에 쌓인 *마이크로태스크 전부*를 처리한다.**
- 처리 순서: script code > 마이크로태스크 > 렌더링 > 매크로태스크. 각 마이크로 태스크 큐 작업이 끝나면 한 번씩 렌더링한다. 이 순서로 인해 모든 마이크로태스크를 동일한 환경에서 처리할 수 있다.
- 새로운 태스크를 스케줄링하는 방법
  - 매크로태스크: 지연시간이 0인 `setTimeout(function)`
  - 마이크로태스크: `queueMicrotask(function)`, Promise handler

## 리액트에서 자주 사용하는 자바스크립트 문법

- 구조 분해 할당

  - 객체와 배열을 변수로 분해한다.
  - 할당 값이 없으면, 기본 값인 `undefined`로 할당한다.
  - 배열 - 할당 연산자 좌측엔 모든 assignables한 것들, 우측엔 모든 iterable이 올 수 있다.
    `let alphabet = {}; 
  [alphabet.a, alphabet.b] = new Set([’a’, ’b’]);` - 예시 - `let [firstName, surname] = arr;` - `let guest = “Jane”;
let admin = "Pete";
[guest, admin] = [admin, guest]; // 변수 교환 트릭` - `let [one, two, …rest] = [1, 2, 3, 4, 5];`
  - 객체
    - 나머지 패턴 `…rest`는 IE, 구식 브라우저들은 지원하지 않는데, babel을 쓰면 된다.
    - 기존 변수에 할당하면 코드 블록으로 인식된다. `()`로 감싼다.
      `*(*{title, width} = {title: "Menu", width: 200}*)*;`
    - 예시
      - `let options = { title: “Menu”, desc: "korean restaurant" ];`
        `let {width: w = 100, height: h = 200, title} = options;`
  - 중첩 구조 분해
    - 객체나 배열이 다른 객체나 배열을 포함하는 경우다.
    - 구조대로 분해해서 할당해야 한다.
  - 매개변수
    - 함수에 매개변수를 전달할 때, 객체로 전달하자. 순서의 영향이 없다.
      주의할 점은 반드시 인수가 전달된다고 가정해야 한다.

- 전개 구문

  - 함수의 정의와 상관없이 함수에 넘겨주는 인수의 개수엔 제약이 없다.
  - 나머지 매개변수 `…`
    - 남아 있는 매개변수들을 한데 모아 배열에 집어 넣어라는 의미
    - 항상 마지막에 있어야 한다.
  - arguments 객체
    - 유사 배열 객체인 `arguments`를 사용하면 인덱스를 사용해 인수에 접근할 수 있다.
    - 배열 메서드는 사용할 수 없고, 인수 전체를 담은 매개변수다.
    - 나머지 매개변수가 나오고 나서는 잘 쓰지 않는다.
  - 스프레드 문법
    - 함수를 호출 할 때, `…array`를 사용하면 이터러블 객체 array가 인수 목록으로 확장된다.
    - `[…”Hello”]; //H,e,l,l,o` - 이터러블 객체만 가능
    - `Array.from(”Hello”); //H,e,l,l,o` - 유사 배열 객체, 이터러블 객체 둘 다 가능
  - 배열과 객체의 복사
    - `Object.assign()`처럼 복사 가능. 원본과 참조가 다르므로 다른 객체.

- 배열

  - 순서가 있는 컬렉션이다. 키는 객체와 같이 추가할 수도 있지만, 임의의 키를 사용할 땐, 배열보다 객체 `{}`를 사용한다.
  - 독립된 자료형이 아닌 객체형에 속한다.
  - 배열 요소의 자료형엔 제약이 없다.
  - 데큐: shift, unshift는 pop, push보다 성능이 느린데, 앞 요소가 제거되면 뒷 요소들의 인덱스가 차례로 하나씩 이동해야하기 때문이다.
    - pop: 끝 요소를 제거하고, 그 요소를 반환.
    - push: 끝에 요소를 추가.
    - shift: 앞 요소를 제거하고, 그 요소를 반환.
    - unshift: 앞에 요소를 추가.
  - 반복문
    - `for..in` - 인덱스
      - 모든 프로퍼티를 대상으로 순회하기 때문에, 키가 숫자가 아니어도 포함된다.
      - 배열이 아닌 객체와의 사용에 최적화되어 있다. **되도록 배열에는 쓰지 말 것.**
    - `for..of` - 요소
      - 배열 전용이며, 값만 얻는다.
    - `for (let i=0; i<arr.length; i++)`
      - 가장 빠르고, 브라우저와 호환성이 좋음.
  - length 프로퍼티
    - 배열 내 요소의 개수가 아니라, **가장 큰 인덱스에 1을 더한 값이다.**
    - 쓰기가 가능하며, 증가시 그만큼 빈 공간이 할당된다. 감소시 배열을 자른다. 그래서 `arr.length = 0;`으로 배열을 비울 수 있다.
  - new Array()
    - `new Array(4) //[empty x 4]`
    - `new Array(1,2,3,4) //[1, 2, 3, 4]`
  - 메서드
    - [**indexOf, lastIndexOf와 includes**](https://ko.javascript.info/array-methods#ref-663)
      - 요소를 찾을 때, 완전 항등 연산자 `===`를 사용한다.
      - includes는 `NaN`도 처리할 수 있다.
    - [sort(fn)](https://ko.javascript.info/array-methods#ref-668)
      - **요소는 문자로 취급되어 재 정렬된다. f.g) “2” > “15”**
      - 문자열 비교엔 `localeCompare`을 사용하기
    - forEach, map, filter
      - break, return으로 중간에 멈출 수 없다.

- 조건 처리
  - if: 실행문이 단 한줄이더라도 `{}`를 사용하여야 한다. 코드 가독성 때문.
  - 삼항 연산자 `?`
  - 다중 `?` - `if..else`처럼 이어붙여서 사용 가능
  - 가독성을 위해 결과를 변수에 할당하지 않는다면, 삼항 연산자 대신 `if..else` 사용 권장

## 선택이 아닌 필수, 타입스크립트

- ts는 기존 js 문법에 타입을 얹은 것이다. 결국 js로 변환되서 js 런타임 환경에서 실행되어야 한다.
- js는 동적 타입 언어라 대부분의 에러코드를 실행 했을 때만 확인할 수 있다.
- 활용법
  - `any` 대신 `unknown`, 그리고 `never`
    - `any`는 예외적인 경우만 사용한다.
    - `unknown`은 모든 값을 할당 할 수 있는 top type이다. `unknown` 값은 우리가 원하는 타입일 때만 실행하도록 로직을 구현할 수도 있다.
    - 반대로, `never`는 아무 타입도 할당 할 수 없다.
  - 타입가드
    - 최대한 타입을 좁히는 것이 좋다.
    - `instanceof`: 특정 클래스의 인스턴스인지 확인.
    - `typeof`: 자료형 확인.
    - `in`: 어떤 객체에 키가 존재하는지 확인.
  - 제네릭
    - 함수나 클래스 내부에서 다양한 타입에 대응할 수 있는 도구.
    - 제네릭도 `T`, `U` 같이 정의하지 말고, 의미를 잘 전달하는 네이밍을 하자.
  - 인덱스 시그니처
    - 객체의 키를 정의하는 방식. `{ [key: string]: string }`
    - 범위가 커지므로, 최대한 지양할 것. `Record<Key, Value>`로 대체하자.
