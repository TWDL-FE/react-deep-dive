# 자바스크립트

## 동등 비교

- 숫자형
  - 내부적으로 64비트 형식으로 표현되므로 64비트가 필요. 52는 숫자, 11은 소수점 위치, 1은 부호를 저장. 64가 넘치면 Infinity 처리
  - Special numeric value 포함. `NaN`, infinity, -infinity
    - `NaN`은 자기 자신을 포함하여 어떤 값과도 같지 않기 때문에 `===`이 아닌 `isNaN`으로 테스트해야한다.
    - `isFinite(value)`는 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환함. 문자열이 일반 숫자인지 검증할 수 있음.
  - 숫자 연산은 안전하기 때문에, 계산중 오류가 발생해도 연산을 종료하지(죽지) 않는다.
- BigInt
  - 9천조 이상의 숫자를 표현. (2에 53승 - 1)
  - 정수 뒤에 n을 붙여 표현 가능
- 문자열
  - escape character(`\`)를 이용해 특수기호를 넣을 수 있다. `\’` . 역슬래시는 문자열을 읽기 위한 용도이며, 역할이 끝나면 사라져 메모리에 저장되는 문자열엔 없다.
  - 문자열은 불변이다.
  - js 내장 함수 뿐만 아니라, 비트 NOT 연산자를 이용해서 문자열을 찾을 수 있다. `if (~str.indexOf(...))` 패턴의 코드를 만나면 '부분 문자열인지 확인’하는 코드다.(32비트를 넘어가지않는 아주 길지 않은 문자열에만 작동)
  - 문자열 비교
    - 소문자는 대문자보다 크다.
    - `str.codePointAt(pos)`를 이용해 문자의 코드를 알아낼 수 있다. 반대도 `String.fromCodePoint(code)` 사용가능.
    - 대부분의 모던 브라우저는 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)를 따르며, [str.localeCompare(str2)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)로 쉽게 알 수 있다.
    - 유니코드 정규화는 보기에는 같은 글자인데 유니코드 조합이 다른 경우, 비교할 수 있게 한다. [str.normalize()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
- null - js에선 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타냄
- undefined
  - 값이 할당되지 않은 상태
  - 변수가 ‘비어있거나’ ‘알 수 없는’ 상태라는 걸 나타내려면 null을 사용. undefined는 값이 할당되지 않은 변수의 초기값을 위해 예약어로 남겨두기.
- 비교 연산자
  - 불린형 반환
    - true: 긍정, 참, 사실
    - false: 부정, 거짓, 사실이 아님
  - 문자열 비교: ‘유니코드’순으로 문자열을 비교. 뒤쪽 문자열이 앞쪽보다 크다고 판단되며, 알파벳의 대소문자를 따짐(소문자가 더 큼).
  - 다른 형을 가진 값 간의 비교: 자료형이 다르면, js는 이 값들을 숫자형으로 바꿈
  - 일치 연산자
    - 동등 연산자(equality operator) `==`는 `0 == false`를 구별 못해, `true` 반환. 숫자로 형 변환후 비교하기 때문.
    - 일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값 비교. `0 === false` 연산으로 `false` 반환.
    - Object.is는 ES6 문법으로, 일치 연산자와 유사하며 그 한계를 극복하기 위해 만들어짐. 객체 비교는 똑같음.
      ```tsx
      Object.is(-0, +0); // false
      Object.is(Number.NaN, NaN); // true
      Object.is(NaN, 0 / 0); // true
      ```
  - null이나 undefined 비교
    - `null === undefined` 자료형이 다르므로 `false`
    - `null == undefined` 특별 규칙으로 `true`
    - 산술 연산자, 기타 비교 연산자 사용하여 비교시, null과 undefined는 숫자형으로 변환
  - null vs 0
    - `==`와 기타 비교 연산자 `<`, `>`, `≤`, `≥`의 동작 방식은 다름. 후자는 `null`이 숫자형으로 변환되고, 전자는 형 변환을 하지 않음.
    - `==`는 `undefined`나 `null`일 때, 형 변환을 하지 않음. 둘끼리 비교할 때만 `true`를 반환하고, 각자 다른 값과 비교할 때는 무조건 `false`를 반환.
  - 비교 연산시 `undefined`나 `null`이 인수로 오지 않도록 특별히 주의하기. 그 여부를 확인하는 코드를 따로 추가하는 습관 들이기.

## 함수

- 프로그램을 구성하는 주요 ‘구성 요소(building block)’이다. 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있다.
- 함수 외부 변수(outer variable)과 똑같이 지역 변수(local variable)을 함수 내부에 재정의 할 수 있다. 함수 내에서 호출시 지역 변수에 의해 외부 변수가 가려진다.
- 매개변수(parameter)는 함수 안에 전달되는데, 이때 지역변수에 복사된 값을 사용하므로 수정해도 외부 변수에 반영되지 않는다. 객체 내부 값들은 원본을 가르키고 있으므로 반영된다.
  - 매개변수는 함수 선언 방식 괄호 사이에 있는 변수(선언 시 쓰이는 용어).
  - 인수는 함수를 호출할 때 매개변수에 전달되는 값(호출 시 쓰이는 용어).
  - 인수를 전달하지 않아도 에러가 발생하진 않고, `undefined`가 기본 값이 된다.
- `return`은 함수 내 어디서든 사용할 수 있고, 함수 실행은 즉시 중단되고 함수를 호출한 곳에 값을 반환한다. `return` 지시자가 없는 함수는 `undefined` 반환.
- 함수 이름만 보고도 어떤 기능을 하는지 알 수 있게 자기 설명적 코드(self-describing)로 작성하기. 즉, 이름에 언급된 동작만 정확히 수행해야 하므로, 함수는 동작 하나만 담당해야 한다. 함수는 동작을 수행하기 때문에 이름이 주로 동사다.
- 함수가 길어지면 잘게 쪼갤 때가 되었다는 신호로 인식하기.
- js에서 함수는 “특별한 종류의 값”이지 “특별한 동작을 하는 구조”가 아니다. 값이므로 `()` 없이 호출되면, 코드가 문자형으로 출력된다.
  - 함수 선언(Function Declaration) `function hello() {}`
    - 실행 흐름이 함수에 도달하기 전에도 호출할 수 있다. 따라서 전역 함수 선언문은 스크립트 어디에서나 사용 가능하다. js는 스크립트 실행 준비 단계에서 함수 선언문을 찾고, 생성한다.
    - 함수가 선언된 코드 블록 안에서만 유효하기 때문에, 블록 밖에서는 접근하지 못한다.
  - 함수 표현식(Function Expression) `let hello = function () {}`
    - 실행 흐름이 함수에 도달했을 때 함수를 생성. 따라서 이때부터 함수를 사용할 수 있다.
    - 코드 블록 외부의 변수에 할당하면, 블록 밖에서 접근 가능하다.
  - 함수 선언 전에 호출, 가독성 때문에 보통은 함수 선언을 더 선호. 이게 부적절할 때 함수 표현식 사용.
- 콜백 함수는 인수로 함수를 전달하고, 필요하다면 그 함수를 “나중에 호출(called back)”하는 것.
- 화살표 함수 `(…args) ⇒ expression`는 본문이 한 줄인 함수를 작성할 때 유용하다.
- 함수도 객체의 일종이다.
- 함수 규칙
  - side effect를 최소한으로 줄이는 순수 함수 지향하기.
  - 가능한 작게 만들고 한가지 일만 하기.
  - 이해하기 쉽고 간단한 이름 붙이기.

## 클래스

- constructor
  - 하나만 가능하고, 없어도 된다.
- instance method
  - 모든 객체는 프로토타입을 가지고 있다. 프로토타입 체이닝은 프로토타입에 있는 메서드를 찾아서 실행을 돕는다. 특정 속성을 찾을 때, 프로토타입을 타고 자기 자신부터 최상위 객체인 Object까지 훑게 된다.
- static method
  - 인스턴스가 아닌 클래스에서 호출한다.
  - this는 인스턴스가 아닌 클래스 자신을 가르키므로, 활용하기 어렵다.

## 클로저

- 코드 블록 `{…}`: 블록 안에서 선언한 변수는 안에서만 사용 가능.
- 중첩 함수(nested): 함수 내부에 선언한 함수
- 렉시컬 환경

  1. 변수
     - js에선 실행 중인 함수, 코드 블록, 스크립트 전체는 렉시컬 환경(Lexical Environment)이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.
     - 렉시컬 환경 객체는 두 부분으로 구성
       - 환경 레코드 - 모든 지역 변수를 프로퍼티로 저장하는 객체. `this`도 포함
       - 외부 렉시컬 환경에 대한 참조 - 외부 코드와 연관됨
     - 변수를 변경하면 환경 레코드의 프로퍼티가 변경된다.
     - 변수는 let을 만나기 전까지 사용할 수 없다.
  2. 함수 선언문
     - 함수 선언문(function declaration)으로 선언한 함수는 일반 변수와 달리 바로 초기화된다. 변수에 함수를 할당한 함수 표현식(function expression)은 변수처럼 초기화된다.
  3. 내부와 외부 렉시컬 환경
     - 코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 찾지 못하면 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 검색 범위를 확장한다. 이 과정은 전역 렉시컬 환경까지 반복된다.
     - 끝내 찾지 못하면 엄격 모드에선 에러가, 비엄격 모드에서는 새로운 전역 변수가 만들어진다.
  4. 함수를 반환하는 함수

     - 모든 함수는 생성된 곳의 렉시컬 환경을 기억한다. 함수는 `[[Environment]]`라는 숨김 프로퍼티(불변)가 있는데, 여기에 생성된 곳의 렉시컬 환경에 대한 참조가 저장된다. 호출 장소와 상관 없다.

     - 변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄진다.

- 클로저
  - 외부 변수를 기억하고 이에 접근할 수 있는 함수.
  - 내부 변수를 외부에서 수정하는 것을 방지하고 정해진 루트로 호출하게 만든다.
